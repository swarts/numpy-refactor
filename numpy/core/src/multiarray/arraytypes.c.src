/* -*- c -*- */
#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "datetime.h"
#include "structmember.h"

#define _MULTIARRAYMODULE
#define NPY_NO_PREFIX
#include "numpy/arrayobject.h"
#include "numpy/arrayscalars.h"
#include "numpy/numpy_api.h"

#include "npy_3kcompat.h"

#include "numpy/npy_math.h"

#include "common.h"
#include "ctors.h"
#include "usertypes.h"
#include "npy_config.h"
#include "_datetime.h"

#include "numpyos.h"


NPY_NO_EXPORT PyArray_Descr * PyArray_DescrNew \
       (PyArray_Descr *);
       
/*
 *****************************************************************************
 **                        PYTHON TYPES TO C TYPES                          **
 *****************************************************************************
 */

double
MyPyFloat_AsDouble(PyObject *obj)
{
    double ret = 0;
    PyObject *num;

    if (obj == Py_None) {
        return NPY_NAN;
    }
    num = PyNumber_Float(obj);
    if (num == NULL) {
        return NPY_NAN;
    }
    ret = PyFloat_AsDouble(num);
    Py_DECREF(num);
    return ret;
}


/**begin repeat
 * #type = long, longlong#
 * #Type = Long, LongLong#
 */
@type@
MyPyLong_As@Type@ (PyObject *obj)
{
    @type@ ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_As@Type@(num);
    Py_DECREF(num);
    return ret;
}

u@type@
MyPyLong_AsUnsigned@Type@ (PyObject *obj)
{
    u@type@ ret;
    PyObject *num = PyNumber_Long(obj);

    if (num == NULL) {
        return -1;
    }
    ret = PyLong_AsUnsigned@Type@(num);
    if (PyErr_Occurred()) {
        PyErr_Clear();
        ret = PyLong_As@Type@(num);
    }
    Py_DECREF(num);
    return ret;
}

/**end repeat**/


/*
 *****************************************************************************
 **                         GETITEM AND SETITEM                             **
 *****************************************************************************
 */


static char * _SEQUENCE_MESSAGE = "error setting an array element with a sequence";

/**begin repeat
 *
 * #TYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, LONG, UINT, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE#
 * #func1 = PyBool_FromLong, PyInt_FromLong*6, PyLong_FromUnsignedLong*2,
 *          PyLong_FromLongLong, PyLong_FromUnsignedLongLong,
 *          PyFloat_FromDouble*2#
 * #func2 = PyObject_IsTrue, MyPyLong_AsLong*6, MyPyLong_AsUnsignedLong*2,
 *          MyPyLong_AsLongLong, MyPyLong_AsUnsignedLongLong,
 *          MyPyFloat_AsDouble*2#
 * #type = Bool, byte, ubyte, short, ushort, int, long, uint, ulong,
 *         longlong, ulonglong, float, double#
 * #type1 = long*7, ulong*2, longlong, ulonglong, float, double#
 * #kind = Bool, Byte, UByte, Short, UShort, Int, Long, UInt, ULong,
 *         LongLong, ULongLong, Float, Double#
*/
PyObject *
@TYPE@_getitem(char *ip, PyArrayObject *ap) {
    @type@ t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((@type@ *)ip);
        return @func1@((@type1@)t1);
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return @func1@((@type1@)t1);
    }
}

int
@TYPE@_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    @type@ temp;  /* ensures alignment */

    if (PyArray_IsScalar(op, @kind@)) {
        temp = ((Py@kind@ScalarObject *)op)->obval;
    }
    else {
        temp = (@type@)@func2@(op);
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError,
                    "setting an array element with a sequence.");
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((@type@ *)ov)=temp;
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}

/**end repeat**/

/**begin repeat
 *
 * #TYPE = CFLOAT, CDOUBLE#
 * #type = float, double#
 */
PyObject *
@TYPE@_getitem(char *ip, PyArrayObject *ap) {
    @type@ t1, t2;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        return PyComplex_FromDoubles((double)((@type@ *)ip)[0],
                (double)((@type@ *)ip)[1]);
    }
    else {
        int size = sizeof(@type@);
        Bool swap = !PyArray_ISNOTSWAPPED(ap);
        copy_and_swap(&t1, ip, size, 1, 0, swap);
        copy_and_swap(&t2, ip + size, size, 1, 0, swap);
        return PyComplex_FromDoubles((double)t1, (double)t2);
    }
}

/**end repeat**/



/**begin repeat
 *
 * #TYPE = CFLOAT, CDOUBLE, CLONGDOUBLE#
 * #type = float, double, longdouble#
 * #kind = CFloat, CDouble, CLongDouble#
 */
int
@TYPE@_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_complex oop;
    PyObject *op2;
    c@type@ temp;
    int rsize;

    if (!(PyArray_IsScalar(op, @kind@))) {
        if (PyArray_Check(op) && (PyArray_NDIM(op) == 0)) {
            op2 = PyArray_DESCR(op)->f->getitem(
                          PyArray_BYTES(op), (PyArrayObject *)op);
        }
        else {
            op2 = op; Py_INCREF(op);
        }
        if (op2 == Py_None) {
            oop.real = NPY_NAN;
            oop.imag = NPY_NAN;
        }
        else {
            oop = PyComplex_AsCComplex (op2);
        }
        Py_DECREF(op2);
        if (PyErr_Occurred()) {
            return -1;
        }
        temp.real = (@type@) oop.real;
        temp.imag = (@type@) oop.imag;
    }
    else {
        temp = ((Py@kind@ScalarObject *)op)->obval;
    }
    memcpy(ov, &temp, PyArray_ITEMSIZE(ap));
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, 2, sizeof(@type@));
    }
    rsize = sizeof(@type@);
    copy_and_swap(ov, &temp, rsize, 2, rsize, !PyArray_ISNOTSWAPPED(ap));
    return 0;
}

/**end repeat**/

/*
 * These return array scalars which are different than other date-types.
 */

PyObject *
LONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, PyArray_DESCR(ap), NULL);
}

int
LONGDOUBLE_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    longdouble temp;

    if (PyArray_IsScalar(op, LongDouble)) {
        temp = ((PyLongDoubleScalarObject *)op)->obval;
    }
    else {
        temp = (longdouble) MyPyFloat_AsDouble(op);
    }
    if (PyErr_Occurred()) {
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap)) {
        *((longdouble *)ov) = temp;
    }
    else {
        copy_and_swap(ov, &temp, PyArray_ITEMSIZE(ap), 1, 0,
                !PyArray_ISNOTSWAPPED(ap));
    }
    return 0;
}

PyObject *
CLONGDOUBLE_getitem(char *ip, PyArrayObject *ap)
{
    return PyArray_Scalar(ip, PyArray_DESCR(ap), NULL);
}

/* UNICODE */
PyObject *
UNICODE_getitem(char *ip, PyArrayObject *ap)
{
    intp elsize = PyArray_ITEMSIZE(ap);
    intp mysize = elsize/sizeof(PyArray_UCS4);
    int alloc = 0;
    PyArray_UCS4 *buffer = NULL;
    PyUnicodeObject *obj;
    intp i;

    if (!PyArray_ISBEHAVED_RO(ap)) {
        buffer = malloc(elsize);
        if (buffer == NULL) {
            PyErr_NoMemory();
            goto fail;
        }
        alloc = 1;
        memcpy(buffer, ip, elsize);
        if (!PyArray_ISNOTSWAPPED(ap)) {
            byte_swap_vector(buffer, mysize, sizeof(PyArray_UCS4));
        }
    }
    else {
        buffer = (PyArray_UCS4 *)ip;
    }
    for (i = mysize; i > 0 && buffer[--i] == 0; mysize = i);

#ifdef Py_UNICODE_WIDE
    obj = (PyUnicodeObject *)PyUnicode_FromUnicode(buffer, mysize);
#else
    /* create new empty unicode object of length mysize*2 */
    obj = (PyUnicodeObject *)MyPyUnicode_New(mysize*2);
    if (obj == NULL) {
        goto fail;
    }
    mysize = PyUCS2Buffer_FromUCS4(obj->str, buffer, mysize);
    /* reset length of unicode object to ucs2size */
    if (MyPyUnicode_Resize(obj, mysize) < 0) {
        Py_DECREF(obj);
        goto fail;
    }
#endif

    if (alloc) {
        free(buffer);
    }
    return (PyObject *)obj;

fail:
    if (alloc) {
        free(buffer);
    }
    return NULL;
}

int
UNICODE_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    PyObject *temp;
    Py_UNICODE *ptr;
    int datalen;
#ifndef Py_UNICODE_WIDE
    char *buffer;
#endif

    if (!PyBytes_Check(op) && !PyUnicode_Check(op) &&
            PySequence_Check(op) && PySequence_Size(op) > 0) {
        PyErr_SetString(PyExc_ValueError,
                "setting an array element with a sequence");
        return -1;
    }
    /* Sequence_Size might have returned an error */
    if (PyErr_Occurred()) {
        PyErr_Clear();
    }
#if defined(NPY_PY3K)
    if (PyBytes_Check(op)) {
        /* Try to decode from ASCII */
        temp = PyUnicode_FromEncodedObject(op, "ASCII", "strict");
        if (temp == NULL) {
            return -1;
        }
    }
    else if ((temp=PyObject_Str(op)) == NULL) {
#else
    if ((temp=PyObject_Unicode(op)) == NULL) {
#endif
        return -1;
    }
    ptr = PyUnicode_AS_UNICODE(temp);
    if ((ptr == NULL) || (PyErr_Occurred())) {
        Py_DECREF(temp);
        return -1;
    }
    datalen = PyUnicode_GET_DATA_SIZE(temp);

#ifdef Py_UNICODE_WIDE
    memcpy(ov, ptr, MIN(PyArray_ITEMSIZE(ap), datalen));
#else
    if (!PyArray_ISALIGNED(ap)) {
        buffer = _pya_malloc(PyArray_ITEMSIZE(ap));
        if (buffer == NULL) {
            Py_DECREF(temp);
            PyErr_NoMemory();
            return -1;
        }
    }
    else {
        buffer = ov;
    }
    datalen = PyUCS2Buffer_AsUCS4(ptr, (PyArray_UCS4 *)buffer,
            datalen >> 1, PyArray_ITEMSIZE(ap) >> 2);
    datalen <<= 2;
    if (!PyArray_ISALIGNED(ap)) {
        memcpy(ov, buffer, datalen);
        _pya_free(buffer);
    }
#endif
    /* Fill in the rest of the space with 0 */
    if (PyArray_ITEMSIZE(ap) > datalen) {
        memset(ov + datalen, 0, (PyArray_ITEMSIZE(ap) - datalen));
    }
    if (!PyArray_ISNOTSWAPPED(ap)) {
        byte_swap_vector(ov, PyArray_ITEMSIZE(ap) >> 2, 4);
    }
    Py_DECREF(temp);
    return 0;
}

/* STRING
 *
 * can handle both NULL-terminated and not NULL-terminated cases
 * will truncate all ending NULLs in returned string.
 */
PyObject *
STRING_getitem(char *ip, PyArrayObject *ap)
{
    /* Will eliminate NULLs at the end */
    char *ptr;
    int size = PyArray_ITEMSIZE(ap);

    ptr = ip + size - 1;
    while (*ptr-- == '\0' && size > 0) {
        size--;
    }
    return PyBytes_FromStringAndSize(ip,size);
}

int
STRING_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    char *ptr;
    Py_ssize_t len;
    PyObject *temp = NULL;

    if (!PyBytes_Check(op) && !PyUnicode_Check(op)
            && PySequence_Check(op) && PySequence_Size(op) > 0) {
        PyErr_SetString(PyExc_ValueError,
                "setting an array element with a sequence");
        return -1;
    }
    /* Sequence_Size might have returned an error */
    if (PyErr_Occurred()) {
        PyErr_Clear();
    }
#if defined(NPY_PY3K)
    if (PyUnicode_Check(op)) {
        /* Assume ASCII codec -- function similarly as Python 2 */
        temp = PyUnicode_AsASCIIString(op);
        if (temp == NULL) return -1;
    }
    else if (PyBytes_Check(op) || PyMemoryView_Check(op)) {
        temp = PyObject_Bytes(op);
        if (temp == NULL) {
            return -1;
        }
    }
    else {
        /* Emulate similar casting behavior as on Python 2 */
        PyObject *str;
        str = PyObject_Str(op);
        if (str == NULL) {
            return -1;
        }
        temp = PyUnicode_AsASCIIString(str);
        Py_DECREF(str);
        if (temp == NULL) {
            return -1;
        }
    }
#else
    if ((temp = PyObject_Str(op)) == NULL) {
        return -1;
    }
#endif
    if (PyBytes_AsStringAndSize(temp, &ptr, &len) == -1) {
        Py_DECREF(temp);
        return -1;
    }
    memcpy(ov, ptr, MIN(PyArray_ITEMSIZE(ap),len));
    /*
     * If string lenth is smaller than room in array
     * Then fill the rest of the element size with NULL
     */
    if (PyArray_ITEMSIZE(ap) > len) {
        memset(ov + len, 0, (PyArray_ITEMSIZE(ap) - len));
    }
    Py_DECREF(temp);
    return 0;
}

/* OBJECT */

#define __ALIGNED(obj, sz) ((((size_t) obj) % (sz))==0)

PyObject *
OBJECT_getitem(char *ip, PyArrayObject *ap)
{
    /* TODO: We might be able to get away with just the "else" clause now */
    if (!ap || PyArray_ISALIGNED(ap)) {
        if (*(PyObject **)ip == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        else {
            Py_INCREF(*(PyObject **)ip);
            return *(PyObject **)ip;
        }
    }
    else {
        PyObject *obj;
        NPY_COPY_PYOBJECT_PTR(&obj, ip);
        if (obj == NULL) {
            Py_INCREF(Py_None);
            return Py_None;
        }
        else {
            Py_INCREF(obj);
            return obj;
        }
    }
}


int
OBJECT_setitem(PyObject *op, char *ov, PyArrayObject *ap)
{
    Py_INCREF(op);
    /* TODO: We might be able to get away with just the "else" clause now */
    if (!ap || PyArray_ISALIGNED(ap)) {
        Py_XDECREF(*(PyObject **)ov);
        *(PyObject **)ov = op;
    }
    else {
        PyObject *obj;
        NPY_COPY_PYOBJECT_PTR(&obj, ov);
        Py_XDECREF(obj);
        NPY_COPY_PYOBJECT_PTR(ov, &op);
    }
    return PyErr_Occurred() ? -1 : 0;
}

/* VOID */

PyObject *
VOID_getitem(char *ip, PyArrayObject *ap)
{
    PyObject *u = NULL;
    PyArray_Descr* descr;
    int itemsize;

    descr = PyArray_DESCR(ap);
    if (NULL != descr->names) {
        char **names;
        int i, n;
        PyObject *ret;
        NpyArray_DescrField *value;
        int savedflags;

        /* get the names from the fields dictionary*/
        names = descr->names;
        if (NULL == names) {
            goto finish;
        }
        for (n=0; NULL != names[n]; n++) ;
        
        ret = PyTuple_New(n);
        savedflags = PyArray_FLAGS(ap);
        for (i = 0; i < n; i++) {
            value = (NpyArray_DescrField *)NpyDict_Get(descr->fields, names[i]);
            if (NULL == value) {
                Py_DECREF(ret);
                PyArray_DESCR(ap) = descr;
                return NULL;
            }
            PyArray_DESCR(ap) = value->descr;
            /* update alignment based on offset */
            if ((value->descr->alignment > 1)
                    && ((((intp)(ip+value->offset)) % value->descr->alignment) != 0)) {
                PyArray_FLAGS(ap) &= ~ALIGNED;
            }
            else {
                PyArray_FLAGS(ap) |= ALIGNED;
            }
            PyTuple_SET_ITEM(ret, i, value->descr->f->getitem(ip +  value->offset, ap));
            PyArray_FLAGS(ap) = savedflags;
        }
        PyArray_DESCR(ap) = descr;
        return ret;
    }

    if (descr->subarray) {
        /* return an array of the basic type */
        PyArrayObject *ret;

        Py_INCREF(descr->subarray->base);
        ret = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,
                descr->subarray->base, descr->subarray->shape_num_dims, 
                descr->subarray->shape_dims,
                NULL, ip, PyArray_FLAGS(ap), NULL);
        if (!ret) {
            return NULL;
        }
        PyArray_BASE_ARRAY(ret) = PyArray_ARRAY(ap);
        _Npy_INCREF(PyArray_BASE_ARRAY(ret));
        assert(NULL == PyArray_BASE_ARRAY(ret) || NULL == PyArray_BASE(ret));
        PyArray_UpdateFlags(ret, UPDATE_ALL);
        return (PyObject *)ret;
    }

finish:
    if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
            || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
        PyErr_SetString(PyExc_ValueError,
                "tried to get void-array with object members as buffer.");
        return NULL;
    }
    itemsize = PyArray_ITEMSIZE(ap);
#if defined(NPY_PY3K)
    /*
     * Return a byte array; there are no plain buffer objects on Py3
     */
    {
        intp dims[1], strides[1];
        PyArray_Descr *descr;
        dims[0] = itemsize;
        strides[0] = 1;
        descr = PyArray_DescrNewFromType(PyArray_BYTE);
        u = PyArray_NewFromDescr(&PyArray_Type, descr, 1, dims, strides,
                                 ip,
                                 PyArray_ISWRITEABLE(ap) ? NPY_WRITEABLE : 0,
                                 NULL);
        PyArray_BASE_ARRAY(u) = PyArray_ARRAY(ap);
        _Npy_INCREF(PyArray_BASE_ARRAY(u));
        assert(NULL == PyArray_BASE_ARRAY(u) || NULL == PyArray_BASE(u));
    }
#else
    /*
     * default is to return buffer object pointing to
     * current item a view of it
     */
    if (PyArray_ISWRITEABLE(ap)) {
        u = PyBuffer_FromReadWriteMemory(ip, itemsize);
    }
    else {
        u = PyBuffer_FromMemory(ip, itemsize);
    }
#endif
    if (u == NULL) {
        goto fail;
    }
    return u;

fail:
    return NULL;
}


NPY_NO_EXPORT int PyArray_CopyObject(PyArrayObject *, PyObject *);

int
VOID_setitem(PyObject *op, char *ip, PyArrayObject *ap)
{
    PyArray_Descr* descr;
    int itemsize=PyArray_ITEMSIZE(ap);
    int res;

    descr = PyArray_DESCR(ap);
    if (descr->names && PyTuple_Check(op)) {
        char **names;
        int i, n;
        NpyArray_DescrField *value;
        int savedflags;

        res = -1;
        /* get the names from the fields dictionary*/
        names = descr->names;
        for (n=0; NULL != names[n]; n++) ;
        if (PyTuple_GET_SIZE(op) != n) {
            PyErr_SetString(PyExc_ValueError,
                    "size of tuple must match number of fields.");
            return -1;
        }
        savedflags = PyArray_FLAGS(ap);
        for (i = 0; i < n; i++) {
            value = (NpyArray_DescrField *)NpyDict_Get(descr->fields, names[i]);
            PyArray_DESCR(ap) = value->descr;
            /* remember to update alignment flags */
            if ((value->descr->alignment > 1)
                    && ((((intp)(ip+value->offset)) % value->descr->alignment) != 0)) {
                PyArray_FLAGS(ap) &= ~ALIGNED;
            }
            else {
                PyArray_FLAGS(ap) |= ALIGNED;
            }
            res = value->descr->f->setitem(PyTuple_GET_ITEM(op, i), ip+value->offset, ap);
            PyArray_FLAGS(ap) = savedflags;
            if (res < 0) {
                break;
            }
        }
        PyArray_DESCR(ap) = descr;
        return res;
    }

    if (descr->subarray) {
        /* copy into an array of the same basic type */
        PyArrayObject *ret;
        Py_INCREF(descr->subarray->base);
        ret = (PyArrayObject *)PyArray_NewFromDescr(&PyArray_Type,
                descr->subarray->base, descr->subarray->shape_num_dims, 
                descr->subarray->shape_dims,
                NULL, ip, PyArray_FLAGS(ap), NULL);
        if (!ret) {
            return -1;
        }
        PyArray_BASE_ARRAY(ret) = PyArray_ARRAY(ap);
        _Npy_INCREF(PyArray_BASE_ARRAY(ret));
        assert(NULL == PyArray_BASE_ARRAY(ret) || NULL == PyArray_BASE(ret));
        PyArray_UpdateFlags((PyArrayObject *)ret, UPDATE_ALL);
        res = PyArray_CopyObject((PyArrayObject *)ret, op);
        Py_DECREF(ret);
        return res;
    }

    /* Default is to use buffer interface to set item */
    {
        const void *buffer;
        Py_ssize_t buflen;
        if (PyDataType_FLAGCHK(descr, NPY_ITEM_HASOBJECT)
                || PyDataType_FLAGCHK(descr, NPY_ITEM_IS_POINTER)) {
            PyErr_SetString(PyExc_ValueError,
                    "Setting void-array with object members using buffer.");
            return -1;
        }
        res = PyObject_AsReadBuffer(op, &buffer, &buflen);
        if (res == -1) {
            goto fail;
        }
        memcpy(ip, buffer, NPY_MIN(buflen, itemsize));
        if (itemsize > buflen) {
            memset(ip + buflen, 0, itemsize - buflen);
        }
    }
    return 0;

fail:
    return -1;
}

/*
 * Acknowledgement:  Example code contributed by Marty Fuhr sponsored by
 * Google Summer of Code 2009 was used to integrate and adapt the mxDateTime
 * parser
 */

/* #include "datetime.c" --- now included in multiarray_onefile */


/* DateTime Objects in Python only keep microsecond resolution.
 *
 * When converting from datetime objects with an event component return a
 * tuple: * (baseunit, number of event)  where baseunit follows is a datetime
 * type and number of events is a Python integer
 */


/*
 * Return a Python Datetime Object from a number representing the number of
 * units since the epoch (1970-01-01T00:00:00Z) ignoring leap seconds.
 */

NPY_NO_EXPORT PyObject *
PyDateTime_FromNormalized(npy_datetime val, NPY_DATETIMEUNIT base)
{
    npy_datetimestruct ydate;

    /* Must be here to use PyDateTime_FromDateAndTime */
    PyDateTime_IMPORT;

    /* We just truncate the unused variables and don't wory about overflow */
    PyArray_DatetimeToDatetimeStruct(val, base, &ydate);

    /* FIXME?: We discard ydate.ns, ydate.ps, ydate.fs, and ydate.as */
    return PyDateTime_FromDateAndTime(ydate.year, ydate.month, ydate.day,
                                      ydate.hour, ydate.min, ydate.sec,
                                      ydate.us);
}

/*
 * We also can lose precision and range here.  Ignored.
 * Don't use this function if you care.
 */

NPY_NO_EXPORT PyObject *
PyTimeDelta_FromNormalized(npy_timedelta val, NPY_DATETIMEUNIT base)
{
    npy_timedeltastruct td;

    PyDateTime_IMPORT;
    PyArray_TimedeltaToTimedeltaStruct(val, base, &td);

    /* We discard td.ps and td.as */
    return PyDelta_FromDSU(td.day, td.sec, td.us);
}


NPY_NO_EXPORT PyObject *
PyDateTime_FromInt64(datetime val, PyArray_Descr *descr)
{
    if (descr->dtinfo == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "datetime info data not set for descriptor");
        return NULL;
    }

    if (descr->dtinfo->events > 1) {
        int events, rem, div;
        PyObject *obj;

        obj = PyTuple_New(2);
        events = descr->dtinfo->events;
        div = val/events;
        rem = val % events;
        PyTuple_SET_ITEM(obj, 1, PyInt_FromLong(rem));
        /* This resets descr->dtinfo->events for recursive call */
        descr->dtinfo->events = 1;
        PyTuple_SET_ITEM(obj, 0, PyDateTime_FromInt64(div, descr));
        descr->dtinfo->events = events;
        if (PyErr_Occurred()) {
            Py_DECREF(obj);
            return NULL;
        }
        return obj;
    }

    /*
     * We normalize the number to a base-unit and then return a
     * Python Datetime Object
     *
     * FIXME? : We silently truncate if it doesn't fit, either too
     *  wide (e.g. 10 BC) or too narrow (nanoseconds)
     */

    /* Normalization and then conversion to Datetime */
    /* FIXME? : Check for Overflow... */
    return PyDateTime_FromNormalized(val*descr->dtinfo->num, descr->dtinfo->base);
}


NPY_NO_EXPORT PyObject *
PyTimeDelta_FromInt64(timedelta val, PyArray_Descr *descr)
{
  if (descr->dtinfo == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "timedelta info data not set for descriptor");
        return NULL;
    }

    if (descr->dtinfo->events > 1) {
        int events, rem, div;
        PyObject *obj;

        obj = PyTuple_New(2);
        events = descr->dtinfo->events;
        div = val/events;
        rem = val % events;
        PyTuple_SET_ITEM(obj, 1, PyInt_FromLong(rem));
        /* This resets descr->dtinfo->events for recursive call */
        descr->dtinfo->events = 1;
        PyTuple_SET_ITEM(obj, 0, PyTimeDelta_FromInt64(div, descr));
        descr->dtinfo->events = events;
        if (PyErr_Occurred()) {
            Py_DECREF(obj);
            return NULL;
        }
        return obj;
    }

    /* FIXME? : Check for Overflow */
    return PyTimeDelta_FromNormalized(val*descr->dtinfo->num, descr->dtinfo->base);
}



NPY_NO_EXPORT npy_datetime
PyDateTime_AsNormalized(PyObject *obj, NPY_DATETIMEUNIT base)
{
    npy_datetimestruct ydate;

    /* Must be here to use PyDateTime_FromDateAndTime */
    PyDateTime_IMPORT;

    if (!PyDateTime_Check(obj) && !PyDate_Check(obj)) {
        PyErr_SetString(PyExc_ValueError,
                "Must be a datetime.date or datetime.datetime object");
        return -1;
    }

    ydate.year = PyDateTime_GET_YEAR(obj);
    ydate.month = PyDateTime_GET_MONTH(obj);
    ydate.day = PyDateTime_GET_DAY(obj);

    if (PyDateTime_Check(obj)) {
        ydate.hour = PyDateTime_DATE_GET_HOUR(obj);
        ydate.min = PyDateTime_DATE_GET_MINUTE(obj);
        ydate.sec = PyDateTime_DATE_GET_SECOND(obj);
        ydate.us = PyDateTime_DATE_GET_MICROSECOND(obj);
    }
    else {
        ydate.hour = 0;
        ydate.min = 0;
        ydate.sec = 0;
        ydate.us = 0;
    }

    ydate.ps = 0;
    ydate.as = 0;

    /* We just truncate the unused variables and don't wory about overflow */
    return PyArray_DatetimeStructToDatetime(base, &ydate);
}

NPY_NO_EXPORT npy_timedelta
PyTimeDelta_AsNormalized(PyObject *obj, NPY_DATETIMEUNIT base)
{
    npy_timedeltastruct td;

    PyDateTime_IMPORT;

    if (!PyDelta_Check(obj)) {
        PyErr_SetString(PyExc_ValueError,
                "Must be a datetime.timedelta object");
        return -1;
    }

    td.day = ((PyDateTime_Delta *)obj)->days;
    td.sec = ((PyDateTime_Delta *)obj)->seconds;
    td.us  = ((PyDateTime_Delta *)obj)->microseconds;
    td.ps  = 0;
    td.as  = 0;

    return PyArray_TimedeltaStructToTimedelta(base, &td);
}


/*
 * These expect a 2-tuple if descr->dtinfo->events > 1  (baseobj, num-counts)
 * where baseobj is a datetime object or a timedelta object respectively.
 *
 */

NPY_NO_EXPORT npy_datetime
PyDateTime_AsInt64(PyObject *obj, PyArray_Descr *descr)
{
    npy_datetime res;

    if (descr->dtinfo == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "datetime info data not set for descriptor");
        return -1;
    }


    if (descr->dtinfo->events > 1) {
        datetime tmp;
        int events;

        if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2) {
            PyErr_SetString(PyExc_ValueError,
                    "need a 2-tuple on setting if events > 1");
            return -1;
        }
        /* Alter the dictionary and call again */
        /* FIXME:  not thread safe */
        events = descr->dtinfo->events;
        descr->dtinfo->events = 1;
        tmp = PyDateTime_AsInt64(PyTuple_GET_ITEM(obj, 0), descr);
        descr->dtinfo->events = events;
        if (PyErr_Occurred()) {
            return -1;
        }
        /* FIXME: Check for overflow */
        tmp *= events;
        tmp += MyPyLong_AsLongLong(PyTuple_GET_ITEM(obj, 1));
        if (PyErr_Occurred()) {
            return -1;
        }
        return tmp;
    }

    res = PyDateTime_AsNormalized(obj, descr->dtinfo->base);
    return res/descr->dtinfo->num;
}


NPY_NO_EXPORT timedelta
PyTimeDelta_AsInt64(PyObject *obj, PyArray_Descr *descr)
{
    npy_timedelta res;

     if (descr->dtinfo == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                "timedelta info data  not set for descriptor");
        return -1;
    }

    if (descr->dtinfo->events > 1) {
        timedelta tmp;
        int events;

        if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2) {
            PyErr_SetString(PyExc_ValueError,
                    "need a 2-tuple on setting if events > 1");
            return -1;
        }
        /* Alter the dictionary and call again (not thread safe) */
        events = descr->dtinfo->events;
        descr->dtinfo->events = 1;
        tmp = PyTimeDelta_AsInt64(PyTuple_GET_ITEM(obj, 0), descr);
        descr->dtinfo->events = events;
        if (PyErr_Occurred()) {
            return -1;
        }
        /* FIXME: Check for overflow */
        tmp *= events;
        tmp += MyPyLong_AsLongLong(PyTuple_GET_ITEM(obj, 1));
        if (PyErr_Occurred()) {
            return -1;
        }
        return tmp;
    }

    res = PyTimeDelta_AsNormalized(obj, descr->dtinfo->base);
    return res / descr->dtinfo->num;
}


/*
 * Always return DateTime Object after normalizing to basic units (or a tuple
 * if descr->dtinfo->events > 1):
 *
 *  Problem:  DateTime does not support all the resolutions (ns) nor the
 *  dynamic range (pre 1 AD) of NumPy Date-times.
 *
 * getitem is not used that much --- if losing resolution hurts, stick
 * with the array scalar versions of the date-time.
 *
 * considered returning array scalars here just like longdouble. This has the
 * problem of recursion in some cases (because in a few places the code
 * expects getitem to return a Python-system object)
 *
 * considered returning different things depending on the resolution but this
 * would make it hard to write generic code  --- but do you need to write
 * generic code on all the frequencies because they cover a wide range.
 *
 * Solution:  The use-case of actually wanting a date-time object when the
 * resolution and dynamic range match, make it the compelling default. When it
 * does fails, there are alternatives for the programmer to use.
 *
 * New question: Should we change (c)longdouble at this point? to return Python Float?
 */

PyObject *
DATETIME_getitem(char *ip, PyArrayObject *ap) {
    datetime t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((datetime *)ip);
        return PyDateTime_FromInt64((datetime)t1, PyArray_DESCR(ap));
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyDateTime_FromInt64((datetime)t1, PyArray_DESCR(ap));
    }
}


PyObject *
TIMEDELTA_getitem(char *ip, PyArrayObject *ap) {
    timedelta t1;

    if ((ap == NULL) || PyArray_ISBEHAVED_RO(ap)) {
        t1 = *((timedelta *)ip);
        return PyTimeDelta_FromInt64((timedelta)t1, PyArray_DESCR(ap));
    }
    else {
        PyArray_DESCR(ap)->f->copyswap(&t1, ip, !PyArray_ISNOTSWAPPED(ap), ap);
        return PyTimeDelta_FromInt64((timedelta)t1, PyArray_DESCR(ap));
    }
}

/* FIXME:
 *  This needs to take
 *      1) Integers and Longs (anything that can be converted to an Int)
 *      2) Strings (ISO-style dates)
 *      3) Datetime Scalars (that it converts based on scalar dtype.
 *      4) Datetime and Date objects
 *  Plus a tuple for descr->dtinfo->events > 1
 *
 *      3) is partially implemented, 4) is implemented
 */

int
DATETIME_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    datetime temp;

    if (PyArray_IsScalar(op, Datetime)) {
        /* This needs to convert based on type */
        temp = ((PyDatetimeScalarObject *)op)->obval;
    }
#if defined(NPY_PY3K)
    else if (PyUString_Check(op)) {
#else
    else if (PyUString_Check(op) || PyUnicode_Check(op)) {
#endif
        /* FIXME:  Converts to DateTime first and therefore does not handle extended notation */
        /* import _mx_datetime_parser 
         * res = _mx_datetime_parser(name)
         *  Convert from datetime to Int
         */
        PyObject *res, *module;

        module = PyImport_ImportModule("numpy.core._mx_datetime_parser");
        if (module == NULL) { return -1; }
        res = PyObject_CallMethod(module, "datetime_from_string", "O", op);
        Py_DECREF(module);
        if (res == NULL) { return -1; }
        temp = PyDateTime_AsInt64(res, PyArray_DESCR(ap));
        Py_DECREF(res);
        if (PyErr_Occurred()) return -1;
    }
    else if (PyInt_Check(op)) {
        temp = PyInt_AS_LONG(op);
    }
    else if (PyLong_Check(op)) {
        temp = PyLong_AsLongLong(op);
    }
    else {
        temp = PyDateTime_AsInt64(op, PyArray_DESCR(ap));
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, _SEQUENCE_MESSAGE);
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((datetime *)ov)=temp;
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}

/* FIXME: This needs to take
 *    1) Integers and Longs (anything that can be converted to an Int)
 *    2) Timedelta scalar objects (with resolution conversion)
 *    3) Python Timedelta objects
 *
 *    Plus a tuple for descr->dtinfo->events > 1
 */

int
TIMEDELTA_setitem(PyObject *op, char *ov, PyArrayObject *ap) {
    /* ensure alignment */
    timedelta temp;

    if (PyArray_IsScalar(op, Timedelta)) {
        temp = ((PyTimedeltaScalarObject *)op)->obval;
    }
    else if (PyInt_Check(op)) {
        temp = PyInt_AS_LONG(op);
    }
    else if (PyLong_Check(op)) {
        temp = PyLong_AsLongLong(op);
    }
    else {
        temp = PyTimeDelta_AsInt64(op, PyArray_DESCR(ap));
    }
    if (PyErr_Occurred()) {
        if (PySequence_Check(op)) {
            PyErr_Clear();
            PyErr_SetString(PyExc_ValueError, _SEQUENCE_MESSAGE);
        }
        return -1;
    }
    if (ap == NULL || PyArray_ISBEHAVED(ap))
        *((timedelta *)ov)=temp;
    else {
        PyArray_DESCR(ap)->f->copyswap(ov, &temp, !PyArray_ISNOTSWAPPED(ap), ap);
    }
    return 0;
}


    
/*
 *****************************************************************************
 **                       TYPE TO TYPE CONVERSIONS                          **
 *****************************************************************************
 */
    
/**begin repeat
 *
 * #FROMTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *             LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *             CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, OBJECT,
 *             DATETIME, TIMEDELTA#
 * #fromtype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *             longlong, ulonglong, float, double, longdouble,
 *             cfloat, cdouble, clongdouble, char, char, char, PyObject *,
 *             datetime, timedelta#
 * #skip = 1*17, aip->array->descr->elsize*3, 1*3#
 */
void
@FROMTYPE@_to_OBJECT(@fromtype@ *ip, PyObject **op, intp n, PyArrayObject *aip,
                 PyArrayObject *NPY_UNUSED(aop))
{
    intp i;
    int skip = @skip@;
    for (i = 0; i < n; i++, ip +=skip, op++) {
        Py_XDECREF(*op);
        *op = @FROMTYPE@_getitem((char *)ip, aip);
    }
}
/**end repeat**/

#define _NPY_UNUSEDBOOL  NPY_UNUSED
#define _NPY_UNUSEDBYTE  NPY_UNUSED
#define _NPY_UNUSEDUBYTE  NPY_UNUSED
#define _NPY_UNUSEDSHORT  NPY_UNUSED
#define _NPY_UNUSEDUSHORT  NPY_UNUSED
#define _NPY_UNUSEDINT  NPY_UNUSED
#define _NPY_UNUSEDUINT  NPY_UNUSED
#define _NPY_UNUSEDLONG  NPY_UNUSED
#define _NPY_UNUSEDULONG  NPY_UNUSED
#define _NPY_UNUSEDLONGLONG  NPY_UNUSED
#define _NPY_UNUSEDULONGLONG  NPY_UNUSED
#define _NPY_UNUSEDFLOAT  NPY_UNUSED
#define _NPY_UNUSEDDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCFLOAT  NPY_UNUSED
#define _NPY_UNUSEDCDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDCLONGDOUBLE  NPY_UNUSED
#define _NPY_UNUSEDDATETIME  NPY_UNUSED
#define _NPY_UNUSEDTIMEDELTA  NPY_UNUSED
#define _NPY_UNUSEDSTRING
#define _NPY_UNUSEDVOID
#define _NPY_UNUSEDUNICODE

/**begin repeat
 *
 * #TOTYPE = BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *           LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *           CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, DATETIME,
 *           TIMEDELTA#
 * #totype = Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *           longlong, ulonglong, float, double, longdouble,
 *           cfloat, cdouble, clongdouble, char, char, char, datetime,
 *           timedelta#
 * #skip = 1*17, aop->array->descr->elsize*3, 1*2#
 */
void
OBJECT_to_@TOTYPE@(PyObject **ip, @totype@ *op, intp n,
        PyArrayObject *_NPY_UNUSED@TOTYPE@(aip), PyArrayObject *aop)
{
    intp i;
    int skip = @skip@;

    for (i = 0; i < n; i++, ip++, op += skip) {
        if (*ip == NULL) {
            @TOTYPE@_setitem(Py_False, (char *)op, aop);
        }
        else {
            @TOTYPE@_setitem(*ip, (char *)op, aop);
        }
    }
}
/**end repeat**/


/**begin repeat
 *
 * #from = STRING*22, UNICODE*22, VOID*22#
 * #fromtyp = char*66#
 * #to = (BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE, CFLOAT, CDOUBLE, CLONGDOUBLE, STRING, UNICODE, VOID, DATETIME, TIMEDELTA)*3#
 * #totyp = (Bool, byte, ubyte, short, ushort, int, uint, long, ulong, longlong, ulonglong, float, double, longdouble, cfloat, cdouble, clongdouble, char, char, char, datetime, timedelta)*3#
 * #oskip = (1*17,aop->array->descr->elsize*3,1*2)*3#
 * #convert = 1*17, 0*3, 1*2, 1*17, 0*3, 1*2, 0*22#
 * #convstr = (Int*9, Long*2, Float*3, Complex*3, Tuple*3, Long*2)*3#
 */
void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = PyArray_ITEMSIZE(aip);
    int oskip = @oskip@;

    for (i = 0; i < n; i++, ip+=skip, op+=oskip) {
        temp = @from@_getitem((char *)ip, aip);
        if (temp == NULL) {
            return;
        }
        /* convert from Python object to needed one */
        if (@convert@) {
            PyObject *new, *args;
            /* call out to the Python builtin given by convstr */
            args = Py_BuildValue("(N)", temp);
#if defined(NPY_PY3K)
#define PyInt_Type PyLong_Type
#endif
            new = Py@convstr@_Type.tp_new(&Py@convstr@_Type, args, NULL);
#if defined(NPY_PY3K)
#undef PyInt_Type
#endif
            Py_DECREF(args);
            temp = new;
            if (temp == NULL) {
                return;
            }
        }
        if (@to@_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}
/**end repeat**/


/**begin repeat
 *
 * #to = STRING*19, UNICODE*19, VOID*19#
 * #totyp = char*19, char*19, char*19#
 * #from = (BOOL, BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG,
 *         LONGLONG, ULONGLONG, FLOAT, DOUBLE, LONGDOUBLE,
 *         CFLOAT, CDOUBLE, CLONGDOUBLE, DATETIME, TIMEDELTA)*3#
 * #fromtyp = (Bool, byte, ubyte, short, ushort, int, uint, long, ulong,
 *            longlong, ulonglong, float, double, longdouble,
 *            cfloat, cdouble, clongdouble, datetime, timedelta)*3#
 */
void
@from@_to_@to@(@fromtyp@ *ip, @totyp@ *op, intp n, PyArrayObject *aip,
             PyArrayObject *aop)
{
    intp i;
    PyObject *temp = NULL;
    int skip = 1;
    int oskip = PyArray_ITEMSIZE(aop);
    for (i = 0; i < n; i++, ip += skip, op += oskip) {
        temp = @from@_getitem((char *)ip, aip);
        if (temp == NULL) {
            Py_INCREF(Py_False);
            temp = Py_False;
        }
        if (@to@_setitem(temp,(char *)op, aop)) {
            Py_DECREF(temp);
            return;
        }
        Py_DECREF(temp);
    }
}

/**end repeat**/


/*
 *****************************************************************************
 **                               SCAN                                      **
 *****************************************************************************
 */


/*
 * The first ignore argument is for backwards compatibility.
 * Should be removed when the API version is bumped up.
 */

/**begin repeat
 * #fname = SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG, ULONGLONG#
 * #type = short, ushort, int, uint, long, ulong, longlong, ulonglong#
 * #format = "hd", "hu", "d", "u", "ld", "lu", LONGLONG_FMT, ULONGLONG_FMT#
 */
int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    return fscanf(fp, "%"@format@, ip);
}
/**end repeat**/

/**begin repeat
 * #fname = FLOAT, DOUBLE, LONGDOUBLE#
 * #type = float, double, longdouble#
 */
int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignored))
{
    double result;
    int ret;

    ret = NumPyOS_ascii_ftolf(fp, &result);
    *ip = (@type@) result;
    return ret;
}
/**end repeat**/

/**begin repeat
 * #fname = BYTE, UBYTE#
 * #type = byte, ubyte#
 * #btype = int, uint#
 * #format = "d", "u"#
 */
int
@fname@_scan(FILE *fp, @type@ *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignore2))
{
    @btype@ temp;
    int num;

    num = fscanf(fp, "%"@format@, &temp);
    *ip = (@type@) temp;
    return num;
}
/**end repeat**/

int
BOOL_scan(FILE *fp, Bool *ip, void *NPY_UNUSED(ignore), PyArray_Descr *NPY_UNUSED(ignore2))
{
    int temp;
    int num;

    num = fscanf(fp, "%d", &temp);
    *ip = (Bool) (temp != 0);
    return num;
}

/**begin repeat
 * #fname = CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, STRING, UNICODE, VOID,
 *          DATETIME, TIMEDELTA#
 */
#define @fname@_scan NULL
/**end repeat**/


/*
 *****************************************************************************
 **                             FROMSTR                                     **
 *****************************************************************************
 */


/**begin repeat
 * #fname = BYTE, UBYTE, SHORT, USHORT, INT, UINT, LONG, ULONG, LONGLONG,
 *          ULONGLONG, DATETIME, TIMEDELTA#
 * #type = byte, ubyte, short, ushort, int, uint, long, ulong, longlong,
 *         ulonglong, datetime, timedelta#
 * #func = (l, ul)*5, l, l#
 * #btype = (long, ulong)*5, long, long#
 */
int
@fname@_fromstr(char *str, @type@ *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    @btype@ result;

    result = PyOS_strto@func@(str, endptr, 10);
    *ip = (@type@) result;
    return 0;
}
/**end repeat**/

/**begin repeat
 *
 * #fname=FLOAT,DOUBLE,LONGDOUBLE#
 * #type=float,double,longdouble#
 */
int
@fname@_fromstr(char *str, @type@ *ip, char **endptr, PyArray_Descr *NPY_UNUSED(ignore))
{
    double result;

    result = NumPyOS_ascii_strtod(str, endptr);
    *ip = (@type@) result;
    return 0;
}
/**end repeat**/



/**begin repeat
 * #fname = BOOL, CFLOAT, CDOUBLE, CLONGDOUBLE, OBJECT, STRING, UNICODE, VOID#
 */
#define @fname@_fromstr NULL
/**end repeat**/



void
OBJECT_copyswapn (PyObject **dst, intp dstride, PyObject **src, intp sstride,
                  intp n, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{
    intp i;
    if (src != NULL) {
        if (__ALIGNED(dst, sizeof(PyObject **))
                && __ALIGNED(src, sizeof(PyObject **))
                && __ALIGNED(dstride, sizeof(PyObject **))
                && __ALIGNED(sstride, sizeof(PyObject **))) {
            dstride /= sizeof(PyObject **);
            sstride /= sizeof(PyObject **);
            for (i = 0; i < n; i++) {
                Py_XINCREF(*src);
                Py_XDECREF(*dst);
                *dst = *src;
                dst += dstride;
                src += sstride;
            }
        }
        else {
            unsigned char *dstp, *srcp;
            PyObject *tmp;
            dstp = (unsigned char*)dst;
            srcp = (unsigned char*)src;
            for (i = 0; i < n; i++) {
                NPY_COPY_PYOBJECT_PTR(&tmp, dstp);
                Py_XDECREF(tmp);
                NPY_COPY_PYOBJECT_PTR(&tmp, srcp);
                Py_XINCREF(tmp);
                NPY_COPY_PYOBJECT_PTR(dstp, srcp);
                dstp += dstride;
                srcp += sstride;
            }
        }
    }
    /* ignore swap */
    return;
}

void
OBJECT_copyswap(PyObject **dst, PyObject **src, int NPY_UNUSED(swap), void *NPY_UNUSED(arr))
{

    if (src != NULL) {
        if (__ALIGNED(dst,sizeof(PyObject **)) && __ALIGNED(src,sizeof(PyObject **))) {
            Py_XINCREF(*src);
            Py_XDECREF(*dst);
            *dst = *src;
        }
        else {
            PyObject *tmp;
            NPY_COPY_PYOBJECT_PTR(&tmp, dst);
            Py_XDECREF(tmp);
            NPY_COPY_PYOBJECT_PTR(&tmp, src);
            Py_XINCREF(tmp);
            NPY_COPY_PYOBJECT_PTR(dst, src);
        }
    }
}




int
OBJECT_compare(PyObject **ip1, PyObject **ip2, PyArrayObject *NPY_UNUSED(ap))
{
    /*
     * ALIGNMENT NOTE: It seems that PyArray_Sort is already handling
     * the alignment of pointers, so it doesn't need to be handled
     * here.
     */
    if ((*ip1 == NULL) || (*ip2 == NULL)) {
        if (ip1 == ip2) {
            return 1;
        }
        if (ip1 == NULL) {
            return -1;
        }
        return 1;
    }
#if defined(NPY_PY3K)
    if (PyObject_RichCompareBool(*ip1, *ip2, Py_LT) == 1) {
        return -1;
    }
    else if (PyObject_RichCompareBool(*ip1, *ip2, Py_GT) == 1) {
        return 1;
    }
    else {
        return 0;
    }
#else
    return PyObject_Compare(*ip1, *ip2);
#endif
}



int
OBJECT_argmax(PyObject **ip, intp n, intp *max_ind, PyArrayObject *NPY_UNUSED(aip))
{
    intp i;
    PyObject *mp = ip[0];

    *max_ind = 0;
    i = 1;
    while (i < n && mp == NULL) {
        mp = ip[i];
        i++;
    }
    for (; i < n; i++) {
        ip++;
#if defined(NPY_PY3K)
        if (*ip != NULL && PyObject_RichCompareBool(*ip, mp, Py_GT) == 1) {
#else
        if (*ip != NULL && PyObject_Compare(*ip, mp) > 0) {
#endif
            mp = *ip;
            *max_ind = i;
        }
    }
    return 0;
}


void
OBJECT_dot(char *ip1, intp is1, char *ip2, intp is2, char *op, intp n,
           void *NPY_UNUSED(ignore))
{
    /*
     * ALIGNMENT NOTE: np.dot, np.inner etc. enforce that the array is
     * BEHAVED before getting to this point, so unaligned pointers aren't
     * handled here.
     */
    intp i;
    PyObject *tmp1, *tmp2, *tmp = NULL;
    PyObject **tmp3;
    for (i = 0; i < n; i++, ip1 += is1, ip2 += is2) {
        if ((*((PyObject **)ip1) == NULL) || (*((PyObject **)ip2) == NULL)) {
            tmp1 = Py_False;
            Py_INCREF(Py_False);
        }
        else {
            tmp1 = PyNumber_Multiply(*((PyObject **)ip1), *((PyObject **)ip2));
            if (!tmp1) {
                Py_XDECREF(tmp);
                return;
            }
        }
        if (i == 0) {
            tmp = tmp1;
        }
        else {
            tmp2 = PyNumber_Add(tmp, tmp1);
            Py_XDECREF(tmp);
            Py_XDECREF(tmp1);
            if (!tmp2) {
                return;
            }
            tmp = tmp2;
        }
    }
    tmp3 = (PyObject**) op;
    tmp2 = *tmp3;
    *((PyObject **)op) = tmp;
    Py_XDECREF(tmp2);
}


/*
 *****************************************************************************
 **                                 FILL                                    **
 *****************************************************************************
 */



/* this requires buffer to be filled with objects or NULL */
void
OBJECT_fill(PyObject **buffer, intp length, void *NPY_UNUSED(ignored))
{
    intp i;
    PyObject *start = buffer[0];
    PyObject *delta = buffer[1];

    delta = PyNumber_Subtract(delta, start);
    if (!delta) {
        return;
    }
    start = PyNumber_Add(start, delta);
    if (!start) {
        goto finish;
    }
    buffer += 2;

    for (i = 2; i < length; i++, buffer++) {
        start = PyNumber_Add(start, delta);
        if (!start) {
            goto finish;
        }
        Py_XDECREF(*buffer);
        *buffer = start;
    }

finish:
    Py_DECREF(delta);
    return;
}



/* this requires buffer to be filled with objects or NULL */
void
OBJECT_fillwithscalar(PyObject **buffer, intp length, PyObject **value, void *NPY_UNUSED(ignored))
{
    intp i;
    PyObject *val = *value;
    for (i = 0; i < length; i++) {
        Py_XDECREF(buffer[i]);
        Py_XINCREF(val);
        buffer[i] = val;
    }
}



